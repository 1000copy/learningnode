## tableview delegate

table view 如何响应事件？ iOS 使用 delegate（委托） 来解决此问题。 

delegate 是一个指向类的引用，此类实现方法告诉 table view 如何响应用户输入，比如触控或者编辑。
具体到 table view ，delegate 协议类为 UITableViewDelegate。我们首先看 table view 如何响应 tap （轻点）事件。

## 实现 tap 事件响应

我们依然显示我喜爱的计算机语言列表，并且可以响应用户轻击事件，在 accessory view 内显示一个对号，当点击其他行时，原来选择行的对号被去掉，当前行设置为对号：

    class LangTableHandleSelection : UITableView,UITableViewDataSource,UITableViewDelegate{
        let arr = ["java","swift","js"]
        override init(frame: CGRect, style: UITableViewStyle) {
            super.init(frame:frame,style:style)
            self.dataSource = self
            self.delegate = self
            
        }
        required init?(coder aDecoder: NSCoder) {
            super.init(coder:aDecoder)
        }
        func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
            return arr.count
        }
        
        func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell {
            let a = UITableViewCell(style: .Default, reuseIdentifier: nil)
            a.textLabel?.text = String(arr[indexPath.row])
            return a
        }
        func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath){
            print("did select \(indexPath.row)")
            self.deselectRowAtIndexPath(indexPath, animated: false)
            if  self.cellForRowAtIndexPath(indexPath)?.accessoryType !=  .Checkmark{
                self.cellForRowAtIndexPath(indexPath)?.accessoryType = .Checkmark
            }else{
                self.cellForRowAtIndexPath(indexPath)?.accessoryType = .None
            }
        }
    }

## 代码说明

首先我们实现一个类，继承自 UITableView 命名为 LangTableHandleSelection，它实现 UITableViewDelegate 协议，并通过 self.delegate = self 达成委托到类实例，然后实现方法 tableView:didSelectRowAtIndexPath:。当 tableview的轻击事件发生时，这个方法就会被调用。我们只要在此方法内实现响应即可。
默认情况下，轻点到行时就会做出选择，效果就是被轻点行被高亮。可是我们不想要这样的效果，因此不好看。如果采用checkmark标记会更漂亮。所以我们首先去掉当前的选择，取代为把 accessoryType = .Checkmark。如果已经是 .Checkmark 就设置为 .None 。此代码实现了对行的单选。


## 实现 tap 事件对行的多项选择

    class LangTableMultiSelection : UITableView,UITableViewDataSource,UITableViewDelegate{
        let arr = ["java","swift","js"]
        override init(frame: CGRect, style: UITableViewStyle) {
            super.init(frame:frame,style:style)
            self.dataSource = self
            self.delegate = self
            
        }
        required init?(coder aDecoder: NSCoder) {
            super.init(coder:aDecoder)
        }
        func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
            return arr.count
        }
        
        func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell {
            let a = UITableViewCell(style: .Default, reuseIdentifier: nil)
            a.textLabel?.text = String(arr[indexPath.row])
            return a
        }
        func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath){
            let r = self.cellForRowAtIndexPath(indexPath)!
            if r.accessoryType == .None {
                r.accessoryType = .Checkmark
            }else{
                r.accessoryType = .None
            }
            self.deselectRowAtIndexPath(indexPath, animated: false)
        }
    }
## 代码说明

响应事件的过程和单选是一样的。不同的仅仅在于
## edit,delete,insert

    class ViewController1: UIViewController {
        var a : LangTableRowDelete?
        override func viewDidLoad() {
            super.viewDidLoad()
            a  = LangTableRowDelete()
            a!.frame = CGRectMake(0,200,300,200)
            self.view.addSubview(a!)
            let b = UIButton()
            b.setTitle("edit", forState: .Normal)
            b.backgroundColor = UIColor.redColor()
            b.addTarget(self, action: "edit:", forControlEvents: .TouchDown)
            
            let c = UIButton()
            c.setTitle("add", forState: .Normal)
            c.backgroundColor = UIColor.yellowColor()
            c.addTarget(self, action: "add:", forControlEvents: .TouchDown)
            
            let d = UIButton()
            d.setTitle("update", forState: .Normal)
            d.backgroundColor = UIColor.blueColor()
            d.addTarget(self, action: "update:", forControlEvents: .TouchDown)
            
            let sv = UIStackView()
            
            sv.backgroundColor = UIColor.grayColor()
            sv.axis = UILayoutConstraintAxis.Horizontal
            sv.distribution = .EqualCentering;
            sv.alignment = .Center;
            sv.spacing = 10;
            sv.frame = CGRectMake(0,100,300,50)
            sv.addArrangedSubview(b)
            sv.addArrangedSubview(c)
            sv.addArrangedSubview(d)
            sv.translatesAutoresizingMaskIntoConstraints = true
            self.view.addSubview(sv)
            
        }
        func edit( b : UIButton!){
            a!.setEditing(true, animated: true)
        }
        func add( b : UIButton!){
            a!.add("new lang")
        }
        func update( b : UIButton!){
            a!.update(1, newlang: "new lang")
        }}


    class LangTableRowDelete : UITableView,UITableViewDataSource,UITableViewDelegate{
        var arr = NSMutableArray.init(array: ["java","swift","js"])
    //    var arr = ["java","swift","js"]
        func add(newlang : String){
        
        arr.insertObject(newlang, atIndex: arr.count )
        beginUpdates()
        insertRowsAtIndexPaths([
            NSIndexPath(forRow: arr.count - 1  , inSection: 0)
            ], withRowAnimation: .Automatic)
        endUpdates()
//            reloadData()
    }
    func update(forRow : Int ,newlang : String){
        arr[forRow] = newlang
        let p = NSIndexPath(forRow: forRow, inSection: 0)
        self.reloadRowsAtIndexPaths([p], withRowAnimation: .Fade)
    }
    override init(frame: CGRect, style: UITableViewStyle) {
        super.init(frame:frame,style:style)
        self.dataSource = self
        self.delegate = self
        
    }
    required init?(coder aDecoder: NSCoder) {
        super.init(coder:aDecoder)
    }
    func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return arr.count
    }
    
    func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell {
        let a = UITableViewCell(style: .Default, reuseIdentifier: nil)
        a.textLabel?.text = String(arr[indexPath.row])
        return a
    }
    //    func tableView(tableView: UITableView, editingStyleForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCellEditingStyle {
    //        if indexPath.row == arr.count - 1 {
    //            return UITableViewCellEditingStyle.Insert
    //        }else{
    //            return UITableViewCellEditingStyle.Delete
    //        }
    //
    //    }
    func tableView(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) {
        if editingStyle ==  .Delete{
            arr.removeObjectAtIndex(indexPath.row) // http://stackoverflow.com/questions/21870680/invalid-update-invalid-number-of-rows-in-section-0
            self.deleteRowsAtIndexPaths([indexPath], withRowAnimation: UITableViewRowAnimation.Fade)
        }
    }
    
}

## reorder

The reordering control is gray, multiple horizontal bar control on the right side of the cell. Users can drag this control to reorder the cell within the table. The default value is NO. If the value is YES , the reordering control temporarily replaces any accessory view.

要显示reorder的控件，必须

1. 在 tableView:cellForRowAtIndexPath:方法内，给cell 设置 .showsReorderControl = true
2. 实现 tableView:canMoveRowAtIndexPath: ,允许cell 被移动
3. 实现 tableView:sourceIndexPath:toIndexPath:

任何一个方法没有实现都不会显示的。

    func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell {
        let a = UITableViewCell(style: .Default, reuseIdentifier: nil)
        a.showsReorderControl = true
        return a
    }
    func tableView(tableView: UITableView, canMoveRowAtIndexPath indexPath: NSIndexPath) -> Bool
    {
        return true;
    }
    func tableView(tableView: UITableView, moveRowAtIndexPath sourceIndexPath: NSIndexPath, toIndexPath destinationIndexPath: NSIndexPath) {
    }

当调用 tableView:sourceIndexPath:toIndexPath: 时，需要把数组内容做一个交换，可以通过这个方法来巧妙的做到：

    func tableView(tableView: UITableView, moveRowAtIndexPath sourceIndexPath: NSIndexPath, toIndexPath destinationIndexPath: NSIndexPath) {
        let f = sourceIndexPath.row
        let t = destinationIndexPath.row
        (arr[f], arr[t]) = (arr[t], arr[f])
    }

调整位置后，可以通过：

    func reordered( b : UIButton!){
        a!.setEditing(false, animated: true)
        a?.reloadData()
    }

完成数据的加载。


2. 每个Cell 都可以在它的 accessory view 内放置控件,比如 UISwitch ，点击这个控件，可以如常的发出事件。

    class LangTableAccessView : UITableView,UITableViewDataSource{
        let arr = ["java","swift","js"]
        override init(frame: CGRect, style: UITableViewStyle) {
            super.init(frame:frame,style:style)
            self.dataSource = self

            
        }
        required init?(coder aDecoder: NSCoder) {
            super.init(coder:aDecoder)
        }
        func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
            return arr.count
        }
        
        func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell {
            let a = UITableViewCell(style: .Default, reuseIdentifier: nil)
            a.textLabel?.text = String(arr[indexPath.row])
            let s = UISwitch()
            s.frame = CGRectMake(0,0,20,20)
            s.addTarget(self, action: "action:", forControlEvents: .ValueChanged)
            s.on = true
            a.accessoryView = s
            return a
        }
        func action(sender : UISwitch!){
            print(sender.on)
        }
    }