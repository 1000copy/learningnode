
##前言

Git 比起SVN的话，本质复杂程度翻了几倍。所以从SVN而来的程序员，学习Git的最大阻力，可能在于怀疑。Hi,哥们，我不过就是做个版本化的工作，提交提交再提交就好了，怎么现在要面对如此多的新概念、命令和参数。

怀疑会令人裹足不前。我一直使用github的GUI，用了几年，虽然期间需要使用命令行，但是并不能说服自己学习Git。然而，Linus闪耀而明亮，Git托管的形势大好。这些现象表明，Git一定是做对了什么，这个对，是我尚且不知的。于是，好奇加上有空，我决定以游戏的心态，去玩玩它。

第一个难关是 git-reset这个命令。它也让我痛恨、令我困惑，git第一次展露了底层细节，这些存储结构是它没有合理掩盖起来的。我终于决定抛弃规则：我愿意深入一层，理解它的存储，甚至于它的实现，从而搞清楚它的功能。难度当然提高了，然后，几次卡壳后，我终于打通关了。

Git引入了本质复杂度。作为是一个分布式的、单机可分支的工具，它引入了新的对象和操作，比如：

1. 为了管理提交的颗粒度，它引入了暂存区（stage），引入了块（Hunk）; 
2. 为了能够分布，它的版本号不再是简单的数字，而是一个看起来令人困惑的字符串（SHA1)

本质复杂度是不可避免的，因为引入一个实体，就意味着引入更多的概念，以及和老实体之间的更多关系。这一点，请读者一定明白，这样才有心理准备——Git就是更难，哪怕封装的再好也是。

另外，它也引入了不少非本质复杂度。此类型复杂度在于设计上的缺陷。比如：

1. 一个命令行引入的功能太多。看看 git reset 子命令即可了解我的意思
2. 概念命名随意。比如暂存区有多个名字，包括Index，Stage，Cache，有些地方使用Index
 ,有些地方使用 Cache、Stage。
3. 命令行参数设计随意。例如 git branch -b 等价于 git branch 后跟 git checkout 

非本质复杂度是可以避免的。实际上，Git 从一个本不知名的工具，到如今的风头正健，本身依然还在演进之中。

无论缺陷还是优点，最终它都令我着迷。我逐步发现，Git 刷新了我对版本工具的认识。

随后你看到的，就是我的研究成果。

你首先看到带有场景的、前后一贯、精心设计的实验；随后引入概念和细节、以及相对不常用的、偏门的东西。 这些知识被封装和分层过了，你可以自顶向下，而不必如我一样，自底向上的干那些脏活了。








