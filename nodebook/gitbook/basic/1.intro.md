#介绍

本章会使用案例文件，来完成一个基本的、但是完整的Git工作流程:

1. 创建Git版本管理仓库（Repository）
2. 创建文件作为版本管理对象，把此文件加入跟踪，多次提交文件变化
3. 查看版本修订历史

有了版本仓库和修订，魔法就来了：

1. 当你文件修改错的时候，可以回溯之前的修订。
2. 可以知道几次修订之间的变化所在。

这就是版本管理的价值。现在，我们通过命令来做一些实验，验证我们的观点。

## 场景

要简单明快的体会Git的版本管理操作，我们得有一个将要被版本管理的文件，它看起来就是这样的一个文本文件。我会修改此文件然后提交到版本仓库，最终文件看起来像是这样：

    （文件名：file1）

    Line1
    Line2
    Line3

##创建版本仓库

在魔法开始前，我们得有一个版本仓库。现在，在你的电脑上找到一个空目录作为工作目录，如果没有就自己建立一个，然后进入到此目录。我的目录是workbench。

Git使用命令git-init来创建一个仓库，加上仓库名为参数：

    $ git init pot 

   Initialized empty Git repository in /Users/lcjun/workbench/pot/.git/

Git输出的提示，说明Repo已经建立。表现形式就是在workbench目录内产生了一个新的叫做pot的目录，并且此目录内还有一个子目录.git。现在，我执行命令，做一个验证：

    $ls -A
    .git

确实可以看到.git隐藏目录是存在的。它就是Git仓库的第一眼看到的样子，Git把所有的版本跟踪信息都放置到此目录内。至于具体内容如何，涉及到Git实现，暂时不需要我们需要操心的了。总之，.git目录就是魔法的开始。

### 创建文件

我们已经在`准备`一章提到，echo可以用来创建文件和在文件尾部添加内容。现在我们使用echo来创建文件，并加入一行文字：

    $ echo line1 > file1 

现在，此文件还没有进入版本管理，我们可以使用git-status命令来验证这一点：

    $ git status -s 
    ?? file1

命令git-status可以现在文件追踪状态。输出有一行文字，被空格分开成两部分，第一个部分表示文件状态，当前显示的状态为两个`??`，表示随后的第二个部分显示的文件还没有进入跟踪状态。所有整个输出表达的含义是文件file1处于未跟踪状态。

### 跟踪新文件，提交修改

可以通过git-add命令把新文件加入跟踪：

    $ git add file1

我们可以再次使用git-status命令来验证：

    $ git status -s 
        A file1

此时输出表明file1的状态处于被添加的状态(added),此状态指明，文件就是已经被跟踪的意思了。

现在在需要使用'git-commit'做一次提交，这样就可以形成一次对仓库的修订了：

    $ git commit -m“init”
    
命令'git-commit'需要参数-m指定提交消息，这里的提交消息使用`""`包括，内容就是`init`。此消息可以是任何文本，作为备注方便用户记录本次提交的概要内容。

我们再次做两次修改并且提交修改到仓库：
    
    echo line2 >> file1
    git add file1
    git commit -m"r1"

    echo line3 >> file1
    git add file1
    git commit -m"r2"


### 看了仓库里有什么

现在我们停下来，稍作思绪的清理：我们做了三次提交，每个修改文件加入一行，提交消息分别为init、r1、r2。实际上仓库里面是否果然有这些修订吗？我们可以使用`git-log`来做验证。此命令会输出所有的修订的概要信息，并以修订时间为依据做降序排序。

    $ git log  head -1

在此命令中，我们：

1. 在第一个参数内使用了head，它被用来表示最近一次提交
2. 使用了参数`-N`来指定输出的总数量，其中的N可以是任何一个正整数。为了分析方便，我们仅仅看最近一条修订，只要给命令一个`-1`参数：

就是说这个命令翻译为自然语言，表达的就是从最近一次修订开始，连续输出它的钱N次修订。N为1。

输出信息看起来是这样的：

    commit 6bc5e700ef6cd8c1b3ed3dd015ab8f4e9df67411
    Author: 1000copy <1000copy@gmail.com>
    Date:   Thu May 19 20:24:03 2016 +0800

        r2

输出的解析如下：

1. 第一行以Commit开始，跟着一个40位的字符串作为标识符。表明它是一个提交对象（commit）。对象标识为d2fe108e92df8d827f6ec237db85693dbd6a1eab
2. 第二行显示的是本次修订的作者和电子邮件。作者是1000copy。正是我使用git-config命令配置的作者的值。电子邮件为1000copy@gmail.com。正是我使用git-config命令配置的电子邮件的值。
3. 第三行是本次修订的日期时间。
4. 接下来一个空行随后就是本次修订的消息。我们的第三次提交，消息为r2，这里显示的正是我们期望的值：r2。

我们随后会单独谈谈那个什么的40位字符串。现在你只要知道此字符串可以唯一表示一个修订。就是说，我们使用head表示最近修订，也就是当前状态下的第三次修订；也可以使用此标识符来指示修订，正如git-log命令的输出显示6bc5e700ef6cd8c1b3ed3dd015ab8f4e9df67411就是我们的第三次修订。因此

    $ git log  head -1 

在当前的场景下也可以写成：
    
    $ git log  6bc5e700ef6cd8c1b3ed3dd015ab8f4e9df67411 -1

输出是完全相同的：

    commit 6bc5e700ef6cd8c1b3ed3dd015ab8f4e9df67411
    Author: 1000copy <1000copy@gmail.com>
    Date:   Thu May 19 20:24:03 2016 +0800

        r2


###继续修改文件file1

    echo line2 >> file1 

然后查看差异

    $ git diff

可以查看输出：

    diff --git a/file1 b/file1
    index a29bdeb..f8be7bb 100644
    --- a/file1
    +++ b/file1
    @@ -1 +1,2 @@
     line1
    +line2
    \ No newline at end of file

输出提示中可以看到，我们加入了一个新行line2。行前的“+”号表示加入了新行，随后是行的内容。

## 添加和提交

    $ git add file1
    $ git commit -m"commit 2" 
    

## 修改

继续添加代码1行。然后我发现这行代码不该写或者写乱了（这是常有的事儿），我想要撤销此工作。那么我可以使用git checkout 命令完成撤销：

    $ echo line3 >> file2 
    $ cat file1
    line1
    line2
    line3

此时代码文件file1内有三行代码

    $ git checkout -- file1
    $ cat file2
    line1
    line2

git-checkout之后就回复到前一个版本，依然是两行代码。

现在，一个速成的git 仓库已经构建：repo已经创建、文件版本已被跟踪，版本已经可供查询。

## 修订标识符

我们稍微放慢脚步，来学习和理解`修订标识符`这个Git中非常重要的概念。

再次使用实验来充分观察和体验它的概念。我们重建一个仓库，并且做三次提交：

    git init p1
    cd p1
    echo line1 > file1 
    git add file1
    git commit -m"r1"
    echo line2 >> file1 
    git commit -m"r2" -a
    echo line3 >> file1 
    git commit -m"r3" -a

然后，我们使用git-log检视下当前的仓库情况。但是这次并不缩写修订标示符，而是原样的把它打印出来。

    git log  --pretty=oneline

输出：

    9e95da0120c263021c74ea4aeee70a3ba345b66e r3
    83b4330d3a8df1df9db73235609990a5054f88e7 r2
    05d68fd95b032e9ce0d6a9a72db12f6c020eba30 r1

我们可以看到，正如期望，输出共有三行，按照修订的倒序显示。就是说最新的修订排在最前面。每个修订的信息为一行，每行的第一个列，就是一个长度为40的字符串，我们称之为“修订标示符”。有了此标识符，我们可以使用命令git-show，把我在git-log中显示的对应修订标示符传递给它。在这里，我选择最后一次修订的标识符：

    git show 9e95da0120c263021c74ea4aeee70a3ba345b66e

于是打印出了更加全面完整的修订信息：

    commit 9e95da0120c263021c74ea4aeee70a3ba345b66e
    Author: 1000copy <1000copy@gmail.com>
    Date:   Mon May 16 17:56:50 2016 +0800

        r3

    diff --git a/file1 b/file1
    index c0d0fb4..83db48f 100644
    --- a/file1
    +++ b/file1
    @@ -1,2 +1,3 @@
     line1
     line2
    +line3

先来查看输出：

1. 此信息的第一行，说明修订标示符为 9e95da0120c263021c74ea4aeee70a3ba345b66e，和我们给git-show命令的参数一致（这是当然的）
2. 第二行显示此修订的作者和电子邮件
3. 第三行为修订时间
4. 随后两个空行之间，是修订时提交的消息，对照之前的仓库构造命令，消息正如期望是r3。
5. 接下来的直到输出结束的多行，只是一个差异信息，就是此修订和它的前一个修订之间的差异。最后一行的
    
    +line3

行开始的“+”说明此修订对前一个修订的变化是添加，添加的是一个内容为line3的行。

特别留意：当你来重做以上命令时，然后执行git-log时，你电脑上打印出来修订标识符是和我不同的。你得使用你的git-log输出的修订标示符。在不同时间，不同电脑用户上运行和我提到的相同的一组命令，最后打印出来的修订标识符是不同的。

类似的，我们可以使用此标识符访问前面的两个修订。

    git show     83b4330d3a8df1df9db73235609990a5054f88e7 05d68fd95b032e9ce0d6a9a72db12f6c020eba30 

命令git-show之后可以传入多个修订标识符，此命令会按照传递的参数的次序，逐个打印对于的修订。

很非常多的Git命令会引用`修订标识符`来完成功能。我们会在随后章节逐步展开。

## 父修订

我们在上一节已经创建了一个仓库，其中有三个修订。且我提到了修订的`前一个修订`这样的说法。在Git系统内，指代前一个修订是有特定名词的——它叫做`父修订`。我们共三次修订，每个修订(除了第一个）都是依赖于它的父修订的。它们构成了这样的关系：
         
    05d68fd95b032e9ce0d6a9a72db12f6c020eba30  <- 83b4330d3a8df1df9db73235609990a5054f88e7 <- 9e95da0120c263021c74ea4aeee70a3ba345b66e 

为了书写方便，我们使用每个修订的对应消息来指代此修订，也就是这样的关系：
    
    r1 <--- r2 <--- r3

修订r1是第一次修订，也叫做初始修订，它是没有父修订的。修订r2的父修订为r1，相应的修订r3的父修订为r2。

我们现在看到的每个修订都有一个父修订。在Git系统中，一个修订是可以有多个父修订的，这种情况出现在分支合并的场景下，会在`分支`一章来详细说明。

### 提交的简化

添加和提交这样的命令组合是非常常用的。因此，Git提供了一个快捷的命令，组合add和commit为一个命令：

首先准备实验环境：
    
    git init p2 
    cd p2
    echo line1 > file1
    git add file1
    git commit file1
    echo line2 >> file1
    
即可组合提交此次修改：

    $ git commit -m"line2"  -a

就是说，可以在commit命令后加入-a选项，就可以把修改了的文件自动的添加到暂存区，并且提交到仓库。

注意，命令git-commit 的参数 `-a`只能把已经加入跟踪的文件加入到暂存区。因此在此案例中，我们看到一个新文件还是需要使用git-add首先加入暂存区之后才能提交的。



大写字母A标志为added的缩写。

在查询状态是，A字母表示added。还有更多缩写：

    ' ' = unmodified
    M = modified
    A = added
    D = deleted
    R = renamed
    C = copied
    U = updated but unmerged

记忆这些字母的含义确实是一个记忆负担，但是熟练后可以大大降低眼球识别负担：只要一个字母就可以知道是什么状态。

现在，我们可以知道file1已经准备好提交了。

留意到一个重要的概念：stage。Git提交文件到仓库，不是直接提交，而是经由stage的。通过git-add把文件添加到stage。而git-commit提交的只能是已经处于stage状态的文件。


### 撤销操作

撤销操作可以把文件添加到暂存区这个操作撤销掉。使用 `git rm --cached <file>` 来撤销这个操作。

    $ git rm --cache file1 

如果你确实做了撤销，那么重新再执行一次添加到暂存区，以便继续接下来的命令。

###提交到仓库

    $ git commit -m"commit 1" 

-m后面输入的是本次提交的说明。


好了，现在我们得深吸一口气，看看这个长长的、像是密码一样的字符串。尽管Git使用这么长的字符串是有各种理由的，但是我们现在不去管它。只要知道使用它就可以唯一定位一个修订（commit）。之所以要给它一个标识，是因为Git会有很多命令需要使用此它，以便从修订历史中找到定位需要的修订对象。

这里要请你注意：我们这里把作为名词用的Commit成为修订。把动词用的Commit叫做提交。在英文里，Commit可以作为动作，也可以作为名词指代对象。但是在中文中都叫做提交就太容易混淆了。

回头来看看这次的命令git-log的输出，它看起来实在太冗余了。毕竟在一个仓库内，作者常常是一致的，且修订标示符也太长了。幸好它可以使用参数来显示更加美好而简洁的输出。如：

    $ git log --abbrev-commit --pretty=oneline
    b4dbd0e commit 1

选项`--pretty=oneline`指示对每一个提交以单行显示。选项`--abbrev-commit`指示缩写Commit的标识符值。这个值默认使用七个字符，不过有时为了避免缩写后可能的冲突，会增加字符数。通常8 到10个字符就已经足够在一个项目中避免标识符冲突。

使用这个缩写的修订标识符可以引用对应的修订。比如，我想要查看commit 1的修改，可以：

    $ git show b4dbd0e
