#介绍

本章会通过一些基本Git命令来完成一个基本的、但是完整的Git工作流程:

1. 创建Git版本仓库（Repository）
2. 创建文件，把它加入跟踪，并多次修改、暂存、提交文件改变到仓库
3. 查看版本修订历史、查阅修订的相对变化

在此过程中，我会引出Git的最基本的概念，如仓库、工作区、暂存、提交、修订等。现在开始实验。

##创建版本仓库

在你的电脑上找到或者创建一个空目录，把它作为工作目录（我的目录是workbench），进入工作目录后，执行：

    git init pot 

命令git-init用来从头创建一个新仓库，参数为仓库名，这里定义仓库名为pot。命令成功执行后在workbench目录内产生了一个叫做pot的新目录。我们看看pot内有什么：
    
    cd pot
    ls -A
输出：    
    .git

可以看到一个名为.git的隐藏目录。对于此目录我们只要知道：Git把本仓库的所有版本跟踪信息都放置到此目录内。除了`.git`目录外，在pot内的全部文件和目录整体构成用户的工作区。你可以在这里完成创建、修改和删除等文件操作。

### 创建文件

我们已经在`准备`一章提到，echo可以用来创建文件和在文件尾部添加内容。现在我们使用echo来创建文件，并加入一行文字：

    echo line1 > file1 

我们可以使用git-status命令来查看版本仓库的状态：

    $ git status -s 
    ?? file1

命令git-status输出有一行文字，被空格分开成两部分，分别为文件所处状态和文件名，此处的文件状态为`??`表示未跟踪状态。这个命令行输出告诉我们，文件file1处于未跟踪状态。

### 跟踪新文件，提交修改

可以通过git-add命令把新文件加入跟踪：

    git add file1

再次使用git-status命令来查看状态：

    $ git status -s 
    A file1

命令行输出的`A`表示状态为`已添加`(added)，就是说，file1已经被加入跟踪了。

现在使用git-commit做提交：

    git commit -m"init"
    
命令git-commit需要参数-m指定提交消息，这里的提交消息是`init`，它由双引号包括起来以便可以包含空格。

我们再做一次修改，然后暂存并提交：
    
    echo line2 >> file1
    git add file1
    git commit -m"r1"

喂，等等。这里读者可能会有疑问：目前总共做了2次提交（commit），第二次提交还是需要git-add来添加。这就奇怪了：不是在第一次提交时就把file1加入跟踪了吗？

两次git-add命令看起来一模一样，但是因为文件当前所处状态的不同，而导致它做的事情并不相同：

1. 第一次git-add，是把未跟踪的文件加入暂存区
2. 第二次git-add，是把文件的修改加入暂存区

Git引入了`暂存区`的概念，git-commit执行时，仅仅把已经放置入暂存区的文件提交到仓库；文件要想被提交，首先需要通过git-add加入暂存区。就是说。Git是有这样的提交三部曲的：修改或者创建新文件、加入暂存区、提交到仓库。

好了，现在我们知道Git会在提交之前加入一个叫做`暂存`的环节了。我们先记住这样的结论，随后章节会对暂存这个环节的价值做进一步分析。

现在我们再做一次修改，然后暂存并提交：
    
    echo line3 >> file1
    git add file1
    git commit -m"r2"


### 看看仓库修订

现在停下来，稍作思绪的清理：我们做了三次提交，每个修改文件加入一行，提交消息分别为init、r1、r2。实际上仓库里面果然有这些修订吗？我们可以使用`git-log`来做验证。此命令会以修订时间为依据做反序排序，打印所有修订的概要信息。

    $ git log  head -1

在此命令中，我们：

1. 第一个参数是head，它被用来指向最近一次修订。这个特殊符号是`引用`的一种。类似的，分支名称也是`引用`的一种
2. 使用了参数`-N`来指定输出的总数量，其中的N可以是任何一个正整数

这样，此命令就容易看懂了：它从最近一次修订开始，列出1个修订的信息。

输出信息看起来是这样的：

    commit 6bc5e700ef6cd8c1b3ed3dd015ab8f4e9df67411
    Author: 1000copy <1000copy@gmail.com>
    Date:   Thu May 19 20:24:03 2016 +0800

        r2

输出的解析如下：

1. 第一行以Commit开始，跟着一个40位的字符串作为标识符。表明它是一个提交对象（commit）。对象标识为d2fe108e92df8d827f6ec237db85693dbd6a1eab
2. 第二行显示的是本次修订的作者和电子邮件。作者是1000copy。正是我使用git-config命令配置的作者的值。电子邮件为1000copy@gmail.com。正是我使用git-config命令配置的电子邮件的值。
3. 第三行是本次修订的日期时间。
4. 接下来一个空行随后就是本次修订的消息。我们的第三次提交，消息为r2。

我们随后会单独谈谈那个长长的40位字符串。现在你只要知道:

1. 此字符串用来唯一表示一个修订。
2. 此字符串每次提交是不同的。同样的文件内容，在不同的用户、不同的时间它也是不同的。

这意味着，你在你的电脑上执行我给出的命令，这个标识符虽然也是40位字符长度，但是值一定是和我不同的。因此，在接下来的命令中如果需要把40位标识符作为参数运行命令的话，那么需要替换为你的git-log输出的对应的标识符，而不可以直接照搬我的。

我们使用head表示最近修订，也可以使用最近修订的标识符来指向修订，因此：

    $ git log  head -1 

在当前的场景下也可以写成：
    
    $ git log  6bc5e700ef6cd8c1b3ed3dd015ab8f4e9df67411 -1

事实上，可以通过diff命令来验证两个命令的输出：

    $ diff <(git log  head -1) <(git log  head -1)

执行完毕后，输出是空的，这表明在括号内的两个命令的输出完全一致。

要输出修订的信息，也可以使用git-show命令，并给命令加上参数`--quiet` 。再次使用diff命令验证，空输出表明两个命令的输出完全相同：

    $ diff <(git log  head -1) <(git show  head --quiet)

命令git-show可以显示一个指定修订的详细情况，如果不使用--quiet参数，就会显示此修订和它的前一个修订之间的差异。

我们到目前为止，共有三个修订在仓库内。我们不希望使用哪个丑陋的字符串做标识符，那么可以换用另一个表示法。Git使用`head~N`这样的格式，来表示从最近提交开始倒数第N个修订，具体说：

1. 使用head指向最近修订。
2. 使用`head~1`指示最近修订的前一个修订
3. 使用`head~2`指示最近修订的前两个修订。

以此类推。

因此：

    $ git show  head~1 --quiet

在当前共三个修订的场景下会打印第2次修订。

    $ git show  head~2 --quiet

在当前共三个修订的场景下会打印第1次修订。

可以使用`git-log`命令列出全部修订，输出：

    commit 6bc5e700ef6cd8c1b3ed3dd015ab8f4e9df67411
    Author: 1000copy <1000copy@gmail.com>
    Date:   Thu May 19 20:24:03 2016 +0800

        r2

    commit 1113041465c48519fc5a46eb0bed004af6d6c0d0
    Author: 1000copy <1000copy@gmail.com>
    Date:   Thu May 19 20:24:03 2016 +0800

        r1

    commit 4c34c35cb760a71cd811b6defc9bf18b703d34fd
    Author: 1000copy <1000copy@gmail.com>
    Date:   Thu May 19 20:17:25 2016 +0800

        init

它简单的把全部3次修订的反序打印出每次修订的信息。要是我们不想在每次执行git-log只想打印修订标识符和消息，而不想显示作者和邮件（毕竟单独的仓库内，这些信息在每次修订显示时基本都是一样的），可以加上参数`--pretty=oneline`：

    git log  --pretty=oneline

输出：

    6bc5e700ef6cd8c1b3ed3dd015ab8f4e9df67411 r2
    1113041465c48519fc5a46eb0bed004af6d6c0d0 r1
    4c34c35cb760a71cd811b6defc9bf18b703d34fd init

这样的输出会更加简明一点。我们可以看到，输出共有三行，每行两列，每一行代表一个修订，按照创建时间倒序显示。第一列为`修订标示符`，因为它是Git使用了SHA1算法来生成的，因此也会称它为SHA1标识。第二列为提交消息。


### 查看差异
可以使用git-diff命令来查看两个修订中某一文件的的差异，比如:

    $ git diff head~1 head  file1

意思是查看file1文件在当前修订和前一个修订中的差异。输出是：

    diff --git a/file1 b/file1
    index c0d0fb4..83db48f 100644
    --- a/file1
    +++ b/file1
    @@ -1,2 +1,3 @@
     line1
     line2
    +line3

可以看到，输出中给最后一行的`+Line3`表示加入了一个新行，行内容为line3。

## 缩写的修订标识符

回头来看看这次的命令`git log  --pretty=oneline`的输出，看起来修订标示符也太长了。幸好它是可以缩写的：

    git log --abbrev-commit --pretty=oneline

    6bc5e70 r2
    1113041 r1
    4c34c35 init

选项`--abbrev-commit`指示缩写Commit的标识符值。这个值一般使用七个字符的缩写。不过有时为了避免缩写后可能的冲突，会增加字符数。通常8 到10个字符就已经足够在一个项目中避免标识符冲突。也可以使用 `git log --oneline` ，效果相同。

使用这个缩写修订标识符可以引用对应的修订。比如，我可以使用6bc5e70作为参数来查看最后一次修订的信息：

    git show 6bc5e70

当然缩写的修订标示符和完整的修订标识符是等效的：

    diff <(git show 6bc5e700ef6cd8c1b3ed3dd015ab8f4e9df67411) <(git show 6bc5e70)

## 更简易的log

我们一再的看到修订标识符的丑模样，它对人类来说太不友好了。我们应该尽可能使用类似head，head~1这样的`引用`去指代修订；类似的想法，是使用`提交消息`来指代修订。在本书的案例中，提交消息都是经过有意的设计，以便看到它就可以知道它指代的修订。为此，使用一个仅仅输出`提交消息`的命令是必要的。你只要给git-log一个`--pretty=format:'%s'`参数即可达成期望：

我们可以做一个对比，当执行：

    git log --abbrev-commit --pretty=oneline

得到如下结果时：

    6bc5e70 r2
    1113041 r1
    4c34c35 init

对应的执行：

    git log --pretty=format:'%s'

输出的就只有提交消息，每个修订一行：

    r2
    r1
    init

使用此命令和参数的配合，足够让我们避开使用修订标示符的编写和阅读负担，而不影响我清晰的传递案例中的修订历史给你了。

## 父修订

我们已经创建了一个仓库，其中有三个修订。且我多次提到了修订的`前一个修订`这样的说法。在Git系统内，指代前一个修订是有特定名词的——它叫做`父修订`。我们共三次修订，每个修订(除了第一个）都是依赖于它的父修订的。
为了书写方便，我们使用每个修订的对应提交消息来指代此修订，图示为这样的关系：
    
    init <- r1 <- r2 

修订init是第一次修订，也叫做初始修订，它是没有父修订的。修订r2的父修订为r1，相应的修订r1的父修订为init。

除了初始修订外，我们现在看到的每个修订都有且只有一个父修订。在Git系统中，一个修订是可以有多个父修订的，这种情况出现在分支合并的场景下，会在`分支`一章来详细说明。

## 命令缩写

我们一直在使用带有很长参数的`git-log`命令来查看提交历史，这样很麻烦。幸好Git可以提供命令别名，从而使用短命令来替代比较长的命令和对应的参数。

### hist

使用别名定义可以把常用的`git-log`调整为简短的别名。执行此命令：

    git config --global alias.hist 'log --pretty=format:"%h %ad | %s%d [%an]" --graph --date=short'

我们不再使用oneline为参数`--pretty`的值，而是使用format来做字符串格式化的输出。其中的：

    %h 为提交的SHA1的缩写值
    %ad 为日期 
    %s  为提交消息
    %d  引用名，一般显示分支名，以及head指向的分支名
    %an 为作者
    --graph 图形化输出分支

使用`git config -l`可以查阅所有配置。如果发现如下行就可以验证我们的配置已经成功：

    alias.hist=log --pretty=format:"%h %ad | %s%d [%an]" --graph --date=short

执行如下命令，来感受一下配置后的效果：

    git hist -2

输出：

    * b638182 2016-05-31 | r2 (HEAD -> roma, master) [1000copy]
    * 8743400 2016-05-31 | r1 [1000copy]

配置后`git-log`本来可以使用的参数hist命令内可以继续使用。比如`-2`限定输入的修订历史条目数不超过2。

### mist

命令git-hist的输出是全面的，然而也是冗余的。我们在本书内为了简便（避开巨长的修订标识符），会使用这样的命令和参数的组合：

    git log --pretty=format:'%s'

我也会给它配置一个别名：

    git config --global alias.mist 'log --pretty=format:"%s"'

此命令仅仅列出每个修订的提交消息:

    git mist -2

    r2
    r1

随后章节也会采用`git-mist`命令做历史查询，特别是无需修订标识符即可说明问题的场合。

