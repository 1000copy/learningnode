#介绍

本章会使用案例文件，来完成一个基本的、但是完整的Git工作流程:

1. 创建Git版本管理仓库（Repository）
2. 创建文件作为版本管理对象，把此文件加入跟踪，多次提交文件变化
3. 查看版本修订历史

有了版本仓库和修订，魔法就来了：

1. 当你文件修改错的时候，可以回溯之前的修订。
2. 可以知道几次修订之间的变化所在。

现在，我们通过命令来做一些实验，验证我们的观点。

## 场景

要简单明快的体会Git的版本管理操作，我们得有一个将要被版本管理的文件，它看起来就是这样的一个文本文件。我会修改此文件然后提交到版本仓库，最终文件看起来像是这样：

    （文件名：file1）

    Line1
    Line2
    Line3

##创建版本仓库

在魔法开始前，我们得有一个版本仓库。现在，在你的电脑上找到一个空目录作为工作目录，如果没有就自己建立一个，然后进入到此目录。我的目录是workbench。

Git 使用命令 git-init 来创建一个仓库，参数是仓库名，这里定义仓库名为 pot：

	[~]$ cd workbench
    [workbench]$ git init pot 
    Initialized empty Git repository in /Users/lcjun/workbench/pot/.git/


Git 的输出提示，说明版本仓库已经建立。workbench 目录内自动生成了一个 pot 目录，及其子目录 .git。现在，我执行命令，做一个验证：

    [workbench]$ cd pot
    [pot]$ls -A
    .git

可以看到一个名为 .git 的隐藏目录。Git把所有本仓库的版本跟踪信息都放置到此目录内。至于具体内容如何，涉及到Git实现，暂时不需要我们需要操心的了。总之，.git目录就是魔法的开始。

### 创建文件

我们已经在`准备`一章提到，echo可以用来创建文件和在文件尾部添加内容。现在我们使用echo来创建文件，并加入一行文字：

    [pot]$ echo line1 > file1 

我们可以使用 git-status 命令来查看版本仓库的状态：

    [pot]$ git status -s 
    ?? file1

命令 git-status 输出有一行文字，被空格分开成两部分，第一个部分表示文件状态，当前显示的状态为两个`??`，表示第二个部分所指示的文件还没有进入跟踪状态。就是说，这个输出表明，文件file1处于未跟踪状态。

### 跟踪新文件，提交修改

可以通过 git-add 命令把新文件加入跟踪：

    $ git add file1

我们可以再次使用git-status命令来验证：

    $ git status -s 
        A file1

此时输出表明 file1 的状态处于被添加的状态(added),此状态指明，文件就是已经被跟踪的意思了。

现在在需要使用'git-commit'做一次提交，这样就可以形成一次对仓库的修订了：

    $ git commit -m"init"
    
命令'git-commit'需要参数-m指定提交消息，这里的提交消息使用`""`包括，内容就是`init`。此消息可以是任何文本，作为备注，方便用户记录本次提交的概要内容。

我们再做一次修改，然后添加并提交：
    
    echo line2 >> file1
    git add file1
    git commit -m"r1"

喂，等等。这里读者可能会有疑问：目前总共做了三次提交（commit），第一次提交之前file1需要通过git-add加入跟踪，第二次提交还是需要git-add，这就奇怪了。既然已经把file1加入跟踪了，为什么第二次提交还是需要git-add呢？

两次git-add命令看起来一模一样，但是在不同的状态下做的事情并不相同：

1. 第一次git-add，是把未跟踪的文件加入暂存区
2. 第二次git-add，是把文件的修改加入暂存区
3. 第三次git-add，同2

Git引入了`暂存区`（Stage）的概念，并由此约定所有需要提交到仓库的修改（包括未跟踪文件、对已跟踪文件的修改），首先需要通过 git-add 加入暂存区，然后 git-commit 提交在暂存区内的文件到仓库。就是说 Git 的提交分三步：修改或者创建新文件、加入暂存区、提交到仓库。

好了，我们现在知道 Git 是这样做的了。新问题随之而来，我干么需要暂存区？直接提交不好吗？我们先记住这个问题，随后章节会对此做进一步解释。


### 看看仓库里有什么

现在我们停下来，清理一下思绪：我们修改了三次文件，每次加入一行并且提交，提交的消息依次为init、r1、r2。实际上仓库里面是否果然有这些修订吗？我们可以使用`git-log`来做验证。此命令会输出所有的修订的概要信息，并以修订时间为依据做降序排序。

    $ git log  head -1

在此命令中，我们：

1. 第一个参数，表示显示的起点，这里使用了head，表示从最近的提交开始，也可以设置成其它任意修订；
2. 第二个参数，表示显示的数量，N可以是任何一个正整数，这里我们使用 -1，即指显示一条修订信息.

用自然语言表达的方式来翻译上面的命令，即为：打印出最近的一次修订的信息。

输出信息看起来是这样的：

    commit 6bc5e700ef6cd8c1b3ed3dd015ab8f4e9df67411
    Author: 1000copy <1000copy@gmail.com>
    Date:   Thu May 19 20:24:03 2016 +0800

        r2

代表的意义如下：

1. 第一行以Commit开始，跟着一个40个字符长度的字符串，字符串即为这个提交的标识符（Tag）。这一行描述了一个提交对象（commit），对象标识为 6bc5e700ef6cd8c1b3ed3dd015ab8f4e9df67411；

2. 第二行显示的是本次修订的作者和电子邮件。作者是1000copy。正是我使用 git-config 命令配置的作者的值。电子邮件为 1000copy@gmail.com，是使用 git-config 命令配置的电子邮件的值；

3. 第三行是本次修订的日期时间；

4. 接下来一个空行随后就是本次修订的消息。我们的第三次提交，消息为 r2，这里显示的正是我们期望的值：r2。

我们随后会单独谈谈那个40个字符的字符串。现在你只要知道:

1. 它可以唯一表示一个修订；

2. 每次提交时都会生成不同的字符串。同样的文件内容，在不同的用户、不同的时间它也是不同的。这意味着，你在你的电脑上执行我给出的命令，这个标识符一定是和我不同的。因此，请注意，接下里的命令中，需要替换为你的 git-log 输出的标识符，命令才能运行成功。

就是说，我们使用head表示最近修订，也就是当前状态下的第三次修订；也可以使用此40位标识符来指示修订，因此

    $ git log  head -1 

在当前的场景下也可以写成：
    
    $ git log  6bc5e700ef6cd8c1b3ed3dd015ab8f4e9df67411 -1

我们可以通过diff命令来验证两个命令的输出是完全相同的：

    $ diff (git log  head -1) (git log  6bc5e700ef6cd8c1b3ed3dd015ab8f4e9df67411 -1)

【----------分隔线-----上面是修订过的部分，先看到这里。：）第一次尝试，看看这样行不行，能否达到效果？或者是否有建议？----】


命令diff运行完成后打印的输出是空的，这个空输出就可以表明在括号内的两个命令的输出是完全一致的，而如果有差异，命令会输出差异信息。要输出修订的信息，也可以使用 git-show 命令，并给命令加上参数`--quiet` 。再次使用diff命令验证，空输出表明两个命令的输出完全相同：

    $ diff <(git log  head -1) <(git show  head --quiet)

命令git-show可以显示一个指定修订的详细情况，如果不使用--quiet参数，就会显示此修订和它的前一个修订之间的差异。

我们到目前为止，共有三个修订在仓库内，我们可以使用head指示最近修订。Git提供一种表示法，使用格式`head~N`表示从最近提交开始倒数第N个修订。比如，可以使用head~1指示最近修订的前一个修订，使用head~2指示最近修订的前两个修订。以此类推。

因此：

    $ git show  head~1 --quiet

在当前共三个修订的场景下会打印第2次修订。

    $ git show  head~2 --quiet

在当前共三个修订的场景下会打印第1次修订。你可以自行执行命令查看输出，验证效果。

可以使用`git-log`命令列出全部修订，输出：

    commit 6bc5e700ef6cd8c1b3ed3dd015ab8f4e9df67411
    Author: 1000copy <1000copy@gmail.com>
    Date:   Thu May 19 20:24:03 2016 +0800

        r2

    commit 1113041465c48519fc5a46eb0bed004af6d6c0d0
    Author: 1000copy <1000copy@gmail.com>
    Date:   Thu May 19 20:24:03 2016 +0800

        r1

    commit 4c34c35cb760a71cd811b6defc9bf18b703d34fd
    Author: 1000copy <1000copy@gmail.com>
    Date:   Thu May 19 20:17:25 2016 +0800

        init

它简单的把全部3次修订的反序打印出每次修订的信息。要是我们不想在每次执行git-log只想打印修订标识符和消息，而不想显示作者和邮件（毕竟单独的仓库内，这些信息在每次修订显示时基本都是一样的），可以加上参数`--pretty=oneline`：

    git log  --pretty=oneline

输出：

    6bc5e700ef6cd8c1b3ed3dd015ab8f4e9df67411 r2
    1113041465c48519fc5a46eb0bed004af6d6c0d0 r1
    4c34c35cb760a71cd811b6defc9bf18b703d34fd init

这样的输出会更加简明一点。我们可以看到，正如期望，输出共有三行，按照修订的倒序显示。就是说最新的修订排在最前面。每个修订的信息为一行，每行的第一个列，就是一个长度为40的字符串，我们称之为“修订标示符”。有了此标识符，我们可以使用命令git-show，把我在git-log中显示的对应修订标示符传递给它。


### 查看差异
可以使用git-diff命令来查看两个修订中某个同一文件的的差异，修订由修订标识符指定，注意head可以作为特殊的修订标识符，表示最近的修订:

    $ git diff head~1 head  file1

意思就是查看修订head~1内的file1和修订head内的file之间的差异。可以查看输出：

    diff --git a/file1 b/file1
    index c0d0fb4..83db48f 100644
    --- a/file1
    +++ b/file1
    @@ -1,2 +1,3 @@
     line1
     line2
    +line3

提示中可以看到，我们加入了一个新行line3。行前的“+”号表示加入了新行，随后是行的内容。

## 缩写的修订标识符

回头来看看这次的命令git-log的输出，它看起来实在太冗余了。毕竟在一个仓库内作者常常是一致的，且修订标示符也太长了。幸好它可以使用参数来显示更加美好而简洁的输出。如：

    $ git log --abbrev-commit --pretty=oneline
    6bc5e70 r2
    1113041 r1
    4c34c35 init

选项`--pretty=oneline`指示对每一个提交以单行显示。选项`--abbrev-commit`指示缩写Commit的标识符值。这个值默认使用七个字符，不过有时为了避免缩写后可能的冲突，会增加字符数。通常8 到10个字符就已经足够在一个项目中避免标识符冲突。

使用这个缩写的修订标识符可以引用对应的修订。比如，我可以使用缩写的修订标识符作为参数来查看r2的修订信息：

    $ git show 6bc5e70

当然缩写的修订标示符和完整的修订标识符是等效的：

    $ diff <(git show 6bc5e700ef6cd8c1b3ed3dd015ab8f4e9df67411) <(git show 6bc5e70)

## 父修订

我们已经创建了一个仓库，其中有三个修订。且我多次提到了修订的`前一个修订`这样的说法。在Git系统内，指代前一个修订是有特定名词的——它叫做`父修订`。我们共三次修订，每个修订(除了第一个）都是依赖于它的父修订的。
为了书写方便，我们使用每个修订的对应提交消息来指代此修订，图示为这样的关系：
    
    init <- r1 <--- r2 

修订init是第一次修订，也叫做初始修订，它是没有父修订的。修订r2的父修订为r1，相应的修订r1的父修订为init。

除了初始修订外，我们现在看到的每个修订都有且只有一个父修订。在Git系统中，一个修订是可以有多个父修订的，这种情况出现在分支合并的场景下，会在`分支`一章来详细说明。


