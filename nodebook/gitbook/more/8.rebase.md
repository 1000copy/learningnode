## rebase 

命令git-rebase可以把一个分支的提交移动到另外一个分支上。此命令会引发合并，正如git-merge那样的合并，和git-merger不同的是，被rebase过的分支的历史就消失了。

我来构建实验环境以便验证rebase的功能。

我们在master分支上做两次提交，然后创建并切换到roma分支，随后做两次提交，在切换回到master分支，做一次提交。

    git init 
    echo line1 > file1
    git add .
    git commit -m"r1"

	echo line2 >> file1
    git commit -m"r2" -a
    
    git checkout -b roma

    echo lineI > file1
    git commit -m"rI" -a

	echo lineII >> file1
    git commit -m"rII" -a

	git checkout  master

	echo line3 >> file1
    git commit -m"r3" -a

我们可以通过查看历史查看以上命令创造出来的一个环境。首先是master分支的3个提交：

    $ git log --oneline
    8913f15 r3
    7f3ad18 r2
    61a0a4f r1

随后，可以看到rome分支的4次提交：

    $ git checkout roma
    Switched to branch 'roma'
    
    Shawshank:git rita$ git log --oneline
    71cfc01 rII
    88270a2 rI
    7f3ad18 r2
    61a0a4f r1

现在我们现在有了两个分支。我们在此环境下，做些实验，来了解rebase的效果。执行以下命令，以便把当前分支master给rebase到roma上：

    git checkout master
    git rebase roma

此命令（git-rebase)的提示信息极为冗长，不过目前我们只要关心其中一行：

    CONFLICT (content): Merge conflict in file1

我们依然遇到了冲突，当然冲突总是长成这幅样子：

    $cat file1
    <<<<<<< d2036f1e48274bceac1ee7d3f508ab17531c8a99
    lineI
    lineII
    =======
    line1
    line2
    line3
    >>>>>>> r3

现在我们解决冲突（为了方便我们直接写入合并后的新内容）:

    echo lineI   > file1
    echo lineII >> file1
    echo line1  >> file1
    echo line2  >> file1 
    echo line3  >> file1

然后加入此改变并继续rebase:

    git add file1
    git rebase --continue
    

这样，整个rebase的过程完成。现在我们再来查看历史：

    git log --oneline
    80dfb59 r3
    d2036f1 rII
    353b3e8 rI
    f840aaf r2
    fb2453d r1

这个输出消息中，我们特别留意到：r3修订的父修订本来是r2，而现在变成了rII。就是说r3的父修订被改变了。是的 ，git-rebase会把指定的分支做一个整体搬移，把它搬到当前分支上。而这，常常会引发冲突。

再次和git-merge对比。当rebase两个分支的代码成果时，我们也会遇到合并代码的情况，这和git-merge是类似的。不同的是merge的历史会出现一个提交有多个父提交的情况，让历史提交显得有些混乱，特别是分支比较多的时候。git-rebase会把的两个分支的历史变成一条单线，这样的历史是很多程序员喜欢的。

我们之前提到了撤销命令。即使像rebase这样的、看起来复杂的命令也是可以恢复的。要点是通过查看git-reflog的输出，确定要撤销的操作的编码。命令git-reflog对于撤销（git-reset)命令来说意义重大，它可以列出所有的操作，然后帮你定位一个撤销点。我们就以当前的操作环境为例:

    $ git reflog

    81994cd HEAD@{0}: rebase finished: returning to refs/heads/master
    81994cd HEAD@{1}: rebase: r3
    1fd3c58 HEAD@{2}: rebase: checkout roma
    e987d5b HEAD@{3}: checkout: moving from master to master
    e987d5b HEAD@{4}: commit: r3
    ed2bea2 HEAD@{5}: checkout: moving from roma to master
    1fd3c58 HEAD@{6}: commit: rII
    6bd7dad HEAD@{7}: commit: rI
    ed2bea2 HEAD@{8}: checkout: moving from master to roma
    ed2bea2 HEAD@{9}: commit: r2
    8776ff9 HEAD@{10}: commit (initial): r1

我们可以看到git-reflog列出了全部的操作，并且最新的操作列在最前面。其中的rebase是由几个操作构成的。现在我们希望恢复到rebase之前，也就是 

    e987d5b HEAD@{4}: commit: r3

要做的就是把 HEAD@{4} 作为参数传递给git-reset 。

    git reset --hard HEAD@{4}

使用参数 --hard 的目的，是撤销不仅修改仓库的当前修订位置，也会同时使用此修订的文件来覆盖本地目录文件。

我们来看log的输出，是否如我们的期望的回到过去:

    git log --oneline
    e987d5b r3
    ed2bea2 r2
    8776ff9 r1
    
    $ git checkout roma
    
    $ git log --oneline
    1fd3c58 rII
    6bd7dad rI
    ed2bea2 r2
    8776ff9 r1

确实回到了r3时的修订历史状况。并且使用命令`$cat file1`也可以发现file1也回到了r3时的内容。

